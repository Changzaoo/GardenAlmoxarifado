import {
  collection,
  getDocs,
  doc,
  setDoc,
  deleteDoc,
  writeBatch,
  query,
  where,
  orderBy,
  limit,
  getDoc,
  Timestamp
} from 'firebase/firestore';

/**
 * üîÑ Servi√ßo de Sincroniza√ß√£o Firebase
 * 
 * Copia e sincroniza cole√ß√µes entre dois projetos Firebase
 */
export class FirebaseSyncService {
  constructor(sourceDb, targetDb) {
    this.sourceDb = sourceDb;
    this.targetDb = targetDb;
    this.syncLog = [];
  }

  /**
   * üìä Log de opera√ß√£o
   */
  log(message, type = 'info', data = null) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      type,
      message,
      data
    };
    
    this.syncLog.push(logEntry);
    
    const emoji = {
      info: '‚ÑπÔ∏è',
      success: '‚úÖ',
      error: '‚ùå',
      warning: '‚ö†Ô∏è'
    }[type] || '‚ÑπÔ∏è';

  }

  /**
   * üì¶ Copiar uma cole√ß√£o completa
   */
  async copyCollection(collectionName, options = {}) {
    try {
      this.log(`Iniciando c√≥pia da cole√ß√£o: ${collectionName}`);

      const {
        batchSize = 500,
        onProgress = null,
        filters = [],
        overwrite = false
      } = options;

      // üõ°Ô∏è Importar valida√ß√£o de usu√°rios
      let validacaoUsuarios = null;
      if (collectionName === 'usuarios') {
        try {
          validacaoUsuarios = await import('../utils/validacaoUsuarios.js');
        } catch (error) {
          console.warn('‚ö†Ô∏è N√£o foi poss√≠vel carregar valida√ß√£o de usu√°rios:', error);
        }
      }

      // Buscar documentos da cole√ß√£o de origem
      const sourceRef = collection(this.sourceDb, collectionName);
      let q = sourceRef;

      // Aplicar filtros se fornecidos
      filters.forEach(filter => {
        q = query(q, where(filter.field, filter.operator, filter.value));
      });

      const snapshot = await getDocs(q);
      const totalDocs = snapshot.size;

      this.log(`${totalDocs} documentos encontrados em ${collectionName}`);

      if (totalDocs === 0) {
        this.log(`Cole√ß√£o ${collectionName} est√° vazia`, 'warning');
        return { success: true, copied: 0, errors: 0, blocked: 0 };
      }

      let copied = 0;
      let errors = 0;
      let blocked = 0;
      let batch = writeBatch(this.targetDb);
      let batchCount = 0;

      // Copiar documentos em lotes
      for (const docSnapshot of snapshot.docs) {
        try {
          const docData = docSnapshot.data();
          
          // üõ°Ô∏è Bloquear usu√°rios admin na c√≥pia
          if (collectionName === 'usuarios' && validacaoUsuarios) {
            if (validacaoUsuarios.deveBloquearNaSincronizacao(docData)) {
              validacaoUsuarios.logBloqueio('c√≥pia de cole√ß√£o', docData);
              this.log(`üö´ Bloqueado usu√°rio proibido: ${docData.usuario || docData.nome}`, 'warning');
              blocked++;
              continue; // Pular este documento
            }
          }
          
          const targetRef = doc(this.targetDb, collectionName, docSnapshot.id);

          // Verificar se documento j√° existe
          if (!overwrite) {
            const existingDoc = await getDoc(targetRef);
            if (existingDoc.exists()) {
              this.log(`Documento ${docSnapshot.id} j√° existe, pulando`, 'warning');
              continue;
            }
          }

          // Adicionar ao batch
          batch.set(targetRef, docData);
          batchCount++;

          // Executar batch quando atingir o limite
          if (batchCount >= batchSize) {
            await batch.commit();
            copied += batchCount;
            this.log(`${copied}/${totalDocs} documentos copiados`, 'success');

            if (onProgress) {
              onProgress(copied, totalDocs);
            }

            // Reiniciar batch
            batch = writeBatch(this.targetDb);
            batchCount = 0;
          }
        } catch (error) {
          errors++;
          this.log(`Erro ao copiar documento ${docSnapshot.id}`, 'error', error);
        }
      }

      // Executar batch restante
      if (batchCount > 0) {
        await batch.commit();
        copied += batchCount;
      }

      this.log(`‚úÖ Cole√ß√£o ${collectionName} copiada: ${copied} documentos`, 'success');

      if (blocked > 0) {
        this.log(`üö´ ${blocked} usu√°rio(s) bloqueado(s) por seguran√ßa`, 'warning');
      }

      return {
        success: true,
        collection: collectionName,
        total: totalDocs,
        copied,
        errors,
        blocked: blocked || 0,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      this.log(`‚ùå Erro ao copiar cole√ß√£o ${collectionName}`, 'error', error);
      return {
        success: false,
        collection: collectionName,
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * üîÑ Sincronizar cole√ß√£o (bidirecional)
   * Compara timestamps e copia apenas documentos mais recentes
   */
  async syncCollection(collectionName, timestampField = 'dataCriacao') {
    try {
      this.log(`Iniciando sincroniza√ß√£o bidirecional: ${collectionName}`);

      const sourceRef = collection(this.sourceDb, collectionName);
      const targetRef = collection(this.targetDb, collectionName);

      const [sourceSnapshot, targetSnapshot] = await Promise.all([
        getDocs(sourceRef),
        getDocs(targetRef)
      ]);

      const sourceMap = new Map();
      const targetMap = new Map();

      // üõ°Ô∏è Importar valida√ß√£o de usu√°rios
      let validacaoUsuarios = null;
      if (collectionName === 'usuarios') {
        try {
          validacaoUsuarios = await import('../utils/validacaoUsuarios.js');
        } catch (error) {
          console.warn('‚ö†Ô∏è N√£o foi poss√≠vel carregar valida√ß√£o de usu√°rios:', error);
        }
      }

      // Mapear documentos de origem
      sourceSnapshot.forEach(docSnapshot => {
        const data = docSnapshot.data();
        
        // üõ°Ô∏è Bloquear usu√°rios admin na sincroniza√ß√£o
        if (collectionName === 'usuarios' && validacaoUsuarios) {
          if (validacaoUsuarios.deveBloquearNaSincronizacao(data)) {
            validacaoUsuarios.logBloqueio('sincroniza√ß√£o (origem)', data);
            this.log(`üö´ Bloqueado usu√°rio proibido: ${data.usuario || data.nome}`, 'warning');
            return; // N√£o adicionar ao mapa
          }
        }
        
        sourceMap.set(docSnapshot.id, { id: docSnapshot.id, data });
      });

      // Mapear documentos de destino
      targetSnapshot.forEach(docSnapshot => {
        const data = docSnapshot.data();
        
        // üõ°Ô∏è Bloquear usu√°rios admin na sincroniza√ß√£o
        if (collectionName === 'usuarios' && validacaoUsuarios) {
          if (validacaoUsuarios.deveBloquearNaSincronizacao(data)) {
            validacaoUsuarios.logBloqueio('sincroniza√ß√£o (destino)', data);
            this.log(`üö´ Bloqueado usu√°rio proibido: ${data.usuario || data.nome}`, 'warning');
            return; // N√£o adicionar ao mapa
          }
        }
        
        targetMap.set(docSnapshot.id, { id: docSnapshot.id, data });
      });

      let copiedToTarget = 0;
      let copiedToSource = 0;
      let updated = 0;
      let blocked = 0;

      // Sincronizar de origem para destino
      for (const [docId, sourceDoc] of sourceMap.entries()) {
        const targetDoc = targetMap.get(docId);

        // üõ°Ô∏è Valida√ß√£o adicional antes de copiar
        if (collectionName === 'usuarios' && validacaoUsuarios) {
          if (validacaoUsuarios.deveBloquearNaSincronizacao(sourceDoc.data)) {
            blocked++;
            continue;
          }
        }

        if (!targetDoc) {
          // Documento n√£o existe no destino - copiar
          await setDoc(doc(this.targetDb, collectionName, docId), sourceDoc.data);
          copiedToTarget++;
        } else {
          // Comparar timestamps
          const sourceTime = sourceDoc.data[timestampField];
          const targetTime = targetDoc.data[timestampField];

          if (this.isNewer(sourceTime, targetTime)) {
            // Origem √© mais recente - atualizar destino
            await setDoc(doc(this.targetDb, collectionName, docId), sourceDoc.data);
            updated++;
          } else if (this.isNewer(targetTime, sourceTime)) {
            // Destino √© mais recente - atualizar origem
            await setDoc(doc(this.sourceDb, collectionName, docId), targetDoc.data);
            copiedToSource++;
          }
        }
      }

      // Copiar documentos que existem apenas no destino
      for (const [docId, targetDoc] of targetMap.entries()) {
        if (!sourceMap.has(docId)) {
          // üõ°Ô∏è Valida√ß√£o adicional antes de copiar
          if (collectionName === 'usuarios' && validacaoUsuarios) {
            if (validacaoUsuarios.deveBloquearNaSincronizacao(targetDoc.data)) {
              blocked++;
              continue;
            }
          }
          
          await setDoc(doc(this.sourceDb, collectionName, docId), targetDoc.data);
          copiedToSource++;
        }
      }

      this.log(
        `‚úÖ Sincroniza√ß√£o conclu√≠da: ${collectionName}`,
        'success',
        { copiedToTarget, copiedToSource, updated, blocked }
      );

      if (blocked > 0) {
        this.log(
          `üö´ ${blocked} usu√°rio(s) bloqueado(s) por seguran√ßa`,
          'warning'
        );
      }

      return {
        success: true,
        collection: collectionName,
        copiedToTarget,
        copiedToSource,
        updated,
        blocked: blocked || 0,
        total: sourceMap.size + targetMap.size,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      this.log(`‚ùå Erro ao sincronizar ${collectionName}`, 'error', error);
      return {
        success: false,
        collection: collectionName,
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * üì¶ Copiar todas as cole√ß√µes
   */
  async copyAllCollections(collections, onProgress = null) {
    this.log(`Iniciando c√≥pia de ${collections.length} cole√ß√µes`);

    const results = [];
    let currentCollection = 0;

    for (const collectionName of collections) {
      currentCollection++;
      
      if (onProgress) {
        onProgress(currentCollection, collections.length, collectionName);
      }

      const result = await this.copyCollection(collectionName, {
        onProgress: (copied, total) => {
          if (onProgress) {
            onProgress(currentCollection, collections.length, collectionName, copied, total);
          }
        }
      });

      results.push(result);

      // Aguardar um pouco entre cole√ß√µes para n√£o sobrecarregar
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    const summary = {
      total: results.length,
      successful: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      totalCopied: results.reduce((sum, r) => sum + (r.copied || 0), 0),
      totalErrors: results.reduce((sum, r) => sum + (r.errors || 0), 0),
      results,
      timestamp: new Date().toISOString()
    };

    this.log(
      `‚úÖ Backup completo conclu√≠do`,
      'success',
      summary
    );

    return summary;
  }

  /**
   * üîÑ Sincronizar todas as cole√ß√µes
   */
  async syncAllCollections(collections, onProgress = null) {
    this.log(`Iniciando sincroniza√ß√£o de ${collections.length} cole√ß√µes`);

    const results = [];
    let currentCollection = 0;

    for (const collectionName of collections) {
      currentCollection++;
      
      if (onProgress) {
        onProgress(currentCollection, collections.length, collectionName);
      }

      const result = await this.syncCollection(collectionName);
      results.push(result);

      // Aguardar um pouco entre cole√ß√µes
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    const summary = {
      total: results.length,
      successful: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      totalSynced: results.reduce((sum, r) => sum + (r.copiedToTarget || 0) + (r.copiedToSource || 0), 0),
      results,
      timestamp: new Date().toISOString()
    };

    this.log(
      `‚úÖ Sincroniza√ß√£o completa conclu√≠da`,
      'success',
      summary
    );

    return summary;
  }

  /**
   * üïê Comparar timestamps
   */
  isNewer(timeA, timeB) {
    if (!timeA) return false;
    if (!timeB) return true;

    const dateA = timeA instanceof Timestamp ? timeA.toDate() : new Date(timeA);
    const dateB = timeB instanceof Timestamp ? timeB.toDate() : new Date(timeB);

    return dateA > dateB;
  }

  /**
   * üìä Obter log de opera√ß√µes
   */
  getLog() {
    return this.syncLog;
  }

  /**
   * üóëÔ∏è Limpar log
   */
  clearLog() {
    this.syncLog = [];
  }
}

/**
 * üéØ Helper para criar inst√¢ncia do servi√ßo
 */
export const createSyncService = (sourceDb, targetDb) => {
  return new FirebaseSyncService(sourceDb, targetDb);
};

export default FirebaseSyncService;
